<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="JavaScript,Unicode," />













<meta name="description" content="转载：http://mp.weixin.qq.com/s/lPb5BtW16-3AQTXecEVlzA原文：www.zcfy.cc/article/what-every-javascript-developer-should-know-about-unicode-1303.html

每次遇到需要Unicode知识的编程问题时，我总是找一个hack方案来解决，但解决方案的原理我也不懂。
直到遇见">
<meta property="og:type" content="article">
<meta property="og:title" content="每个JavaScript开发者都该懂的Unicode">
<meta property="og:url" content="http://liqianglai.github.com/2017/08/30/每个JavaScript开发者都该懂的Unicode/index.html">
<meta property="og:site_name" content="朝花夕拾">
<meta property="og:description" content="转载：http://mp.weixin.qq.com/s/lPb5BtW16-3AQTXecEVlzA原文：www.zcfy.cc/article/what-every-javascript-developer-should-know-about-unicode-1303.html

每次遇到需要Unicode知识的编程问题时，我总是找一个hack方案来解决，但解决方案的原理我也不懂。
直到遇见">
<meta property="og:image" content="http://liqianglai.github.com/images/20170830/1.jpg">
<meta property="og:image" content="http://liqianglai.github.com/images/20170830/2.jpg">
<meta property="og:image" content="http://liqianglai.github.com/images/20170830/3.jpg">
<meta property="og:image" content="http://liqianglai.github.com/images/20170830/4.jpg">
<meta property="og:updated_time" content="2017-08-31T09:58:20.833Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="每个JavaScript开发者都该懂的Unicode">
<meta name="twitter:description" content="转载：http://mp.weixin.qq.com/s/lPb5BtW16-3AQTXecEVlzA原文：www.zcfy.cc/article/what-every-javascript-developer-should-know-about-unicode-1303.html

每次遇到需要Unicode知识的编程问题时，我总是找一个hack方案来解决，但解决方案的原理我也不懂。
直到遇见">
<meta name="twitter:image" content="http://liqianglai.github.com/images/20170830/1.jpg">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'ff'
    }
  };
</script>




  <link rel="canonical" href="http://liqianglai.github.com/2017/08/30/每个JavaScript开发者都该懂的Unicode/"/>


  <title> 每个JavaScript开发者都该懂的Unicode | 朝花夕拾 </title>
</head>

<body itemscope itemtype="//schema.org/WebPage" lang="zh-Hans">

  



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?d94085bc233783cf9876ecb573c01944";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>








  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="//schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">朝花夕拾</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">记录所学，分享所得。</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="st-search-show-outputs">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <form class="site-search-form">
  <input type="text" id="st-search-input" class="st-search-input st-default-search-input" />
</form>

<script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
    (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
    e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

  _st('install', 'VpiymvJcxS-wv1dEHLvr','2.0.0');
</script>



    </div>
  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                每个JavaScript开发者都该懂的Unicode
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-08-30T11:57:52+08:00" content="2017-08-30">
              2017-08-30
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/朝花夕拾/" itemprop="url" rel="index">
                    <span itemprop="name">朝花夕拾</span>
                  </a>
                </span>

                
                
                  ， 
                

              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/朝花夕拾/转载/" itemprop="url" rel="index">
                    <span itemprop="name">转载</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/08/30/每个JavaScript开发者都该懂的Unicode/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/08/30/每个JavaScript开发者都该懂的Unicode/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2017/08/30/每个JavaScript开发者都该懂的Unicode/" class="leancloud_visitors" data-flag-title="每个JavaScript开发者都该懂的Unicode">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <blockquote>
<p>转载：<a href="http://mp.weixin.qq.com/s/lPb5BtW16-3AQTXecEVlzA" target="_blank" rel="external">http://mp.weixin.qq.com/s/lPb5BtW16-3AQTXecEVlzA</a><br>原文：<a href="www.zcfy.cc/article/what-every-javascript-developer-should-know-about-unicode-1303.html">www.zcfy.cc/article/what-every-javascript-developer-should-know-about-unicode-1303.html</a></p>
</blockquote>
<p>每次遇到需要Unicode知识的编程问题时，我总是找一个hack方案来解决，但解决方案的原理我也不懂。</p>
<p>直到遇见一个需要深入了解Unicode知识才能解决的问题，我才停止了这种逃避。因为这个问题没办法应用特定情境的解决方案。</p>
<p>在努力读了一大堆文章之后，我惊讶地发现Unicode并不难懂。好吧，确实是有些文章起码得看3遍才能看懂。</p>
<p>但我发现Unicode标准不仅世界通用，而且十分优雅简洁，只不过要理解其中一些抽象概念有点困难。</p>
<p>如果你觉得理解Unicode很难，那么是时候来面对它了！其实它没你想的那么难。去沏一杯香浓的茶或咖啡吧☕，让我们进入抽象概念、字符、星光平面(辅助平面)和代理对的世界。</p>
<p>本文首先会解释Unicode中的基本概念，这是必需的背景知识。</p>
<p>然后会说明JavaScript如何解析Unicode，以及你可能踩到哪些坑。</p>
<p>你还会学到如何利用ECMAScript 2015的新特性来解决部分难题。</p>
<p>准备好了？那就燥起来吧!</p>
<a id="more"></a>
<h4 id="1-Unicode背后的思想"><a href="#1-Unicode背后的思想" class="headerlink" title="1. Unicode背后的思想"></a>1. Unicode背后的思想</h4><p>首先问一个最基础的问题：你是怎样阅读并理解这篇文章的？答案很简单，因为你明白这些字以及由字组成的单词的含义。</p>
<p>那你又是如何明白这些字的含义的呢？答案也很简单，因为你（读者）和我（作者）对于这些（呈现在屏幕上的）图形与汉字（即含义）之间的联系有着相同的认知。</p>
<p>对计算机来说这个原理也差不多，只有一点不同：计算机不懂这些字（字母）的含义，只是将其理解为特定的比特序列。</p>
<p>让我们设想一个情景：计算机<code>User1</code>向计算机<code>User2</code>发送一条消息<code>&#39;hello&#39;</code>。</p>
<p>计算机并不知道这些字母的含义。所以计算机<code>User1</code>将消息<code>&#39;hello&#39;</code>转换为一串数字序列<code>0x68 0x65 0x6C 0x6C 0x6F</code>，每个字母对应一个数字：<code>h</code>对应<code>0x68</code>, <code>e</code>对应<code>0x65</code>，等等。</p>
<p>接着将这些数字发送给计算机<code>User2</code>。</p>
<p>计算机<code>User2</code>收到数字序列<code>0x68 0x65 0x6C 0x6C 0x6F</code>后，使用同一套字母与数字的对应关系重建消息内容，<code>&#39;hello&#39;</code>就能正确地显示出来了。</p>
<p>不同计算机之间对字母与数字之间对应关系的协议就是Unicode进行标准化的结果。</p>
<p>根据Unicode，<code>h</code>是一个名为<code>LATIN SMALL LETTER H</code>的抽象字符。这个抽象字符对应数字<code>0x68</code>，也就是一个标记为<code>U+0068</code>的代码点。这些概念将在下一章中说明。</p>
<p>Unicode的作用就是提供一个抽象字符列表（字符集），并给每一个字符分配一个独一无二的标识符代码点（编码字符集）。</p>
<h4 id="2-Unicode基本概念"><a href="#2-Unicode基本概念" class="headerlink" title="2. Unicode基本概念"></a>2. Unicode基本概念</h4><p>Unicode为每一个字符分配一个专有的数字<strong>不分平台、不分程序、不分语言</strong></p>
<p>Unicode是一个世界通用的字符集，它定义了全世界大部分书写体系的字符集，并为每一个字符分配了一个独一无二的数字（代码点）。<br><img src="/images/20170830/1.jpg" alt=""></p>
<p>Unicode囊括了大部分现代语言、标点符号、附加符号（变音符）、数学符号、技术符号、箭头和表情符号等。</p>
<p>Unicode第一版1.0于1991年10月发布，包含7161个字符。最新版9.0（2016年6月发布）则提供了128172个字符的编码。</p>
<p>Unicode的通用性与开放性解决了过去一直存在的一个问题：供应商们各自实现不同的字符集和编码规则，很难处理。</p>
<p>创建一个支持所有字符集和编码规则的应用是十分复杂的。更不用说你选用的编码可能不支持所有你需要的语言。</p>
<p>如果你觉得Unicode很难，那就想想如果没有它编程会更难。</p>
<p>我还记得从前随机选择所需的字符集和编码规则去读取文件内容的时候。全靠人品啊！</p>
<h5 id="2-1-字符与代码点"><a href="#2-1-字符与代码点" class="headerlink" title="2.1 字符与代码点"></a>2.1 字符与代码点</h5><blockquote>
<p>抽象字符（即文本字符）是用来组织、管理或表现文本数据的信息单位。</p>
</blockquote>
<p>Unicode中的字符是一个抽象概念。每一个抽象字符都有一个对应的名称，例如<code>LATIN SMALL LETTER A</code>。该抽象字符的图像表现形式<code>glyph</code>是<code>a</code>。（译者注：glyph即图像字符）</p>
<blockquote>
<p>代码点是指被分配给某个抽象字符的数字</p>
</blockquote>
<p>代码点以U<code>+&lt;hex&gt;</code>的形式表示，<code>U+</code>是代表Unicode的前缀，而<code>&lt;hex&gt;</code>是一个16进制数。例如<code>U+0041</code>和<code>U+2603</code>都是代码点。</p>
<p>代码点的取值范围是从<code>U+0000</code>到<code>U+10FFFF</code>。</p>
<p>记住代码点就是一个简单的数字。思考有关Unicode的问题时要记得这一点。</p>
<p>代码点就好像数组元素的下标。</p>
<p>Unicode的神奇之处就在于将代码点与抽象字符关联起来。例如<code>U+0041</code>对应的抽象字符名为<code>LATIN CAPITAL LETTER A</code> (表现为<code>A</code>)，而<code>U+2603</code>对应的抽象字符名为<code>SNOWMAN</code>(表现为<code>☃</code>)</p>
<p>注意，并非所有的代码点都有对应的抽象字符。可用的代码点有<code>1114112</code>个，但分配了抽象字符的只有<code>128237</code>个。</p>
<h5 id="2-2-Unicode平面"><a href="#2-2-Unicode平面" class="headerlink" title="2.2 Unicode平面"></a>2.2 Unicode平面</h5><blockquote>
<p>平面是指从<code>U+n0000</code>到<code>U+nFFFF</code>的区间，也就是<code>65536（1000016）</code>个连续的Unicode代码点，<code>n</code>的取值范围是从<code>016</code>到<code>1016</code>。</p>
</blockquote>
<ul>
<li>这些平面将Unicode代码点分为17个大小相等的集合：</li>
<li>平面0包含从U+0000到U+FFFF的代码点</li>
<li>平面1包含从U+<strong>1</strong>0000到U+<strong>1</strong>FFFF的代码点</li>
<li>…</li>
<li>平面16包含从U+<strong>10</strong>0000到U+<strong>10</strong>FFFF的代码点</li>
</ul>
<p><img src="/images/20170830/2.jpg" alt=""></p>
<h6 id="基本多文种平面"><a href="#基本多文种平面" class="headerlink" title="基本多文种平面"></a>基本多文种平面</h6><p>平面0比较特殊，被称为基本多文种平面或简称BMP。它包含了大多数现代语言的字符 (基本拉丁字母, 西里尔字母, 希腊字母等)和大量的符号。</p>
<p>如上文所述，基本多文种平面的代码点取值范围是从<code>U+0000</code>到<code>U+FFFF</code>，最多可以有4位16进制数字。</p>
<p>大多数时候开发者处理的都是BMP中的字符。它包含了大多数情况下的必需字符。</p>
<p>BMP中的一些字符：</p>
<ul>
<li><code>e</code>对应代码点<code>U+0065</code> 抽象字符名： <code>LATIN SMALL LETTER E</code></li>
<li><code>|</code>对应代码点<code>U+007C</code> 抽象字符名： <code>VERTICAL BAR</code></li>
<li><code>■</code>对应代码点<code>U+25A0</code> 抽象字符名： <code>BLACK SQUARE</code></li>
<li><code>☂</code>对应代码点<code>U+2602</code> 抽象字符名： <code>UMBRELLA</code></li>
</ul>
<h6 id="星光平面"><a href="#星光平面" class="headerlink" title="星光平面"></a>星光平面</h6><p>BMP之后的16个平面（平面1，平面2，…，平面16）被称为星光平面或辅助平面。</p>
<p>星光平面的代码点被称为星光代码点。这些代码点的取值范围是从U+10000到U+10FFFF。</p>
<p>星光代码点可能会有5位或6位16进制数字：U+ddddd或U+dddddd。</p>
<p>来看几个星光平面里的字符：</p>
<ul>
<li>对应<code>U+1D11E</code>抽象字符名：<code>MUSICAL SYMBOL G CLEF</code></li>
<li>对应<code>U+1D401</code>抽象字符名：<code>MATHEMATICAL BOLD CAPITAL B</code></li>
<li>对应<code>U+1F035</code>抽象字符名：<code>DOMINO TITLE HORIZONTAL-00-04</code></li>
<li>对应<code>U+1F600</code>抽象字符名：<code>GRINNING FACE</code></li>
</ul>
<h5 id="2-3-码元"><a href="#2-3-码元" class="headerlink" title="2.3 码元"></a>2.3 码元</h5><p>计算机在存储时当然不会使用代码点或抽象字符，它们是存在于开发者大脑中的概念。</p>
<p>所以自然要有一种在物理层面表示Unicode代码点的方式：码元。</p>
<blockquote>
<p>码元是指使用某种给定的编码规则给抽象字符编码后得到的比特序列。</p>
</blockquote>
<p>字符编码将抽象层面的代码点转换为物理层面的比特序列：码元。</p>
<p>换句话说，字符编码的作用就是将Unicode代码点翻译成独一无二的码元序列。</p>
<p>常用的字符编码有UTF-8, UTF-16 和 UTF-32.</p>
<p>大多数JavaScript引擎使用UTF-16编码字符。它会影响JavaScript处理Unicode的方式。所以从这里开始让我们集中精力于UTF-16吧。</p>
<p>UTF-16（全称：16位统一码转换格式）是一种变长编码:</p>
<ul>
<li>BMP中的代码点编码为单个16位的码元</li>
<li>星光平面的代码点编码为两个16位的码元</li>
</ul>
<p>来看几个例子</p>
<p>假设我们想把<code>LATIN SMALL LETTER A</code>，也就是抽象字符<code>a</code>存入硬盘。Unicode告诉我们抽象字符<code>LATIN SMALL LETTER A</code>对应代码点<code>U+0061</code>。</p>
<p>现在我们来看看UTF-16如何转换<code>U+0061</code>。编码规范上说，对于BMP中的代码点只需将它的16进制数字<code>U+0061</code>存入一个16位的码元就行了。</p>
<p>显然，BMP中的代码点刚好能存进一个16位的码元。编码BMP可谓小菜一碟。</p>
<h5 id="2-4-代理对"><a href="#2-4-代理对" class="headerlink" title="2.4 代理对"></a>2.4 代理对</h5><p>现在让我们来研究一个复杂些的例子。假设我们想存储一个星光代码点（属于星光平面）：GRINNING FACE character 。该字符对应的代码点是 U+1F600。</p>
<p>由于星光代码点需要21个比特来存储字符信息，UTF-16需要两个码元来编码，每个16比特。代码点 U+1F600 被拆分为所谓的代理对：0xD83D（高位代理码元）与0xDE00（低位代理码元）。</p>
<blockquote>
<p>代理对用来表示那些对应2个16位码元序列的抽象字符，其中第一个码元是高位代理码元而第二个是低位代理码元。</p>
</blockquote>
<p>编码一个星光代码点需要两个码元：即一个代理对。比如前面那个例子，使用UTF-16编码<code>U+1F600</code> ()就使用了一个代理对：<code>0xD83D</code> <code>0xDE00</code>。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="string">'\uD83D\uDE00'</span>); <span class="comment">// =&gt; ''</span></div></pre></td></tr></table></figure></p>
<p>高位代理码元的取值范围是从0xD800到0xDBFF。 低位代理码元的取值范围是从0xDC00到0xDFFF。</p>
<p>代理对与代码点之间互相转换的算法如下所示：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSurrogatePair</span>(<span class="params">astralCodePoint</span>) </span>&#123;  </div><div class="line">  <span class="keyword">let</span> highSurrogate =</div><div class="line">     <span class="built_in">Math</span>.floor((astralCodePoint - <span class="number">0x10000</span>) / <span class="number">0x400</span>) + <span class="number">0xD800</span>;</div><div class="line">  <span class="keyword">let</span> lowSurrogate = (astralCodePoint - <span class="number">0x10000</span>) % <span class="number">0x400</span> + <span class="number">0xDC00</span>;</div><div class="line">  <span class="keyword">return</span> [highSurrogate, lowSurrogate];</div><div class="line">&#125;</div><div class="line">getSurrogatePair(<span class="number">0x1F600</span>); <span class="comment">// =&gt; [0xDC00, 0xDFFF]</span></div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAstralCodePoint</span>(<span class="params">highSurrogate, lowSurrogate</span>) </span>&#123;  </div><div class="line">  <span class="keyword">return</span> (highSurrogate - <span class="number">0xD800</span>) * <span class="number">0x400</span></div><div class="line">      + lowSurrogate - <span class="number">0xDC00</span> + <span class="number">0x10000</span>;</div><div class="line">&#125;</div><div class="line">getAstralCodePoint(<span class="number">0xD83D</span>, <span class="number">0xDE00</span>); <span class="comment">// =&gt; 0x1F600</span></div></pre></td></tr></table></figure></p>
<p>代理对并不是一个令人愉快的东西。在JavaScript中处理字符串时我们必须将它们视为特殊情况来处理，具体内容我们在下章细说。</p>
<p>但UTF-16的存储效率很高。因为99%需要处理的字符都属于BMP，只需要1个码元。</p>
<h5 id="2-5-组合用字符"><a href="#2-5-组合用字符" class="headerlink" title="2.5 组合用字符"></a>2.5 组合用字符</h5><blockquote>
<p>在一个书写系统的上下文中，一个字素或者符号是最小的可区分单元。</p>
</blockquote>
<p>字素就是用户所认为的一个字符。屏幕上所展示的一个有形的字素称为图像字符（glyph）。</p>
<p>在大多数情况下，一个Unicode字符就代表一个字素。例如 <code>U+0066 LATIN SMALL LETTER F</code>就是一个英文字母<code>f</code>。</p>
<p>但有时候一个字素会包含一系列字符。</p>
<p>例如å在丹麦语书写系统中是一个不可再分的字素。但它是用<code>U+0061 LATIN SMALL LETTER A</code> (渲染为<code>a</code>) 结合一个特殊字符<code>U+030A COMBINING RING ABOVE</code>（渲染为<code>◌̊</code>）来显示的。</p>
<p>U+030A用来修饰前一个字符，这种字符称为组合用字符。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="string">'\u0061\u030A'</span>); <span class="comment">// =&gt; 'å'  </span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'\u0061'</span>);       <span class="comment">// =&gt; 'a'</span></div></pre></td></tr></table></figure></p>
<blockquote>
<p>组合用字符是应用在前一个基础字符上以形成完整字素的字符。</p>
</blockquote>
<p>组合用字符包括以下字符：重音符号、变音符、希伯来语点、阿拉伯语元音符号和印度语节拍符。</p>
<p>组合用字符通常不会离开基础字符单独使用。我们应该避免单独显示它们。</p>
<p>与代理对一样，在JavaScript中处理组合用字符也很棘手。</p>
<p>在用户看来一个组合字符序列（<code>基础字符+组合用字符</code>）是【一】个符号（例如<code>&#39;\u0061\u030A&#39;</code>就是<code>&#39;å&#39;</code>）。但开发者必须清楚实际上要用到两个代码点<code>U+0061</code>和<code>U+030A</code>来生成<code>å</code>。<br><img src="/images/20170830/3.jpg" alt=""></p>
<h4 id="3-JavaScript中的Unicode"><a href="#3-JavaScript中的Unicode" class="headerlink" title="3. JavaScript中的Unicode"></a>3. JavaScript中的Unicode</h4><p>ES2015规范提到源代码文本使用Unicode（5.1及以上版本）表示。源码文本是一串取值范围从<code>U+0000</code>到<code>U+10FFFF</code>的代码点序列。尽管ECMAScript规范没有指明源码储存和交换的方式，但通常都以UTF-8编码（在web中推荐使用的编码）。</p>
<p>我建议将源代码文本控制在<code>Basic Latin Unicode block</code>（或者说ASCII）中。超出ASCII的字符应该避免使用。这能保证源码文本在编码时少出些问题。</p>
<p>ECMAScript 2015在语言层面上给出了JavaScript中String（字符串）的明确定义：</p>
<p>String类型是由16比特无符号整型数值（“元素”）组成的集合，最少包含0个元素，最多包含253-1个元素。String类型通常用来在运行ECMAScript的程序中表示文本信息，因此String中的每个元素都被当作一个UTF-16码元值。</p>
<p>字符串中的每一个元素都会被引擎解释为一个码元。而字符串的渲染结果并不能明确地反映它包含的码元（及其所代表的代码点）。看下面这个例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="string">'cafe\u0301'</span>); <span class="comment">// =&gt; 'café'  </span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'café'</span>);       <span class="comment">// =&gt; 'café'</span></div></pre></td></tr></table></figure></p>
<p>虽然字面量’cafe\u0301’和’café’有轻微的差别，但两者都被渲染为同样的字符序列café。</p>
<p>字符串的长度是指其中包含的元素（即16位数值）的个数。ECMAScript在解释String类型时，字符串的每一个元素都被解释为一个UTF-16码元。</p>
<p>从上一章关于代理对和组合用字符的内容可知，某些字符需要2个以上的码元来表示。所以在计算字符长度或通过字符串索引访问字符时要格外小心。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> smile = <span class="string">'\uD83D\uDE00'</span>;  </div><div class="line"><span class="built_in">console</span>.log(smile);        <span class="comment">// =&gt; ''  </span></div><div class="line"><span class="built_in">console</span>.log(smile.length); <span class="comment">// =&gt; 2</span></div><div class="line"> </div><div class="line"><span class="keyword">let</span> letter = <span class="string">'e\u0301'</span>;  </div><div class="line"><span class="built_in">console</span>.log(letter);        <span class="comment">// =&gt; 'é'  </span></div><div class="line"><span class="built_in">console</span>.log(letter.length); <span class="comment">// =&gt; 2</span></div></pre></td></tr></table></figure></p>
<p>字符串<code>smile</code>包含两个码元：<code>\uD83D</code> （高位代理）和<code>\uDE00</code>（低位代理）。由于字符串是码元的序列，因此尽管 <code>smile</code> 的渲染结果只有一个字符’’，<code>smile.length</code>的值却为<code>2</code>。</p>
<p>对于字符串<code>letter</code>也一样。组合用字符<code>U+0301</code>应用于前一个字符，渲染结果是一个字符’é’。然而<code>letter</code>包含2个码元，因此<code>letter.length</code>值为2。</p>
<p>我的建议是：始终将JavaScript中的字符串视为一串码元序列。字符串渲染的结果并不能清晰地表明它包含了怎样的码元。</p>
<p>星光符号和组合字符序列需要2个以上的码元来编码，却被视为一个语素。</p>
<p>如果字符串中含有代理对或组合用字符，而开发者又不清楚这一点，那么在计算字符串长度或通过索引访问字符时就可能会感到困惑。</p>
<p>大多数JavaScript字符串方法都不能识别Unicode。如果字符串含有混合的Unicode字符，在调用<code>myString.slice()</code>、<code>myString.substring()</code>等方法时就要小心了。</p>
<h5 id="3-1-转义序列"><a href="#3-1-转义序列" class="headerlink" title="3.1 转义序列"></a>3.1 转义序列</h5><p>JavaScript字符串中的转义序列通常都是基于代码点数字的。JavaScript有3种转义模式，在ECMAScript 2015中有相关介绍。</p>
<p>来详细看看这几种模式吧。</p>
<p>16进制转义序列</p>
<p>最简短的形式称为16进制转义序列：<code>\x&lt;hex&gt;</code>. <code>\x</code>为前缀，后面跟一个2位的16进制数。</p>
<p>比如<code>\x30</code>（字符 <code>0</code>）和<code>\x5B</code>（字符 <code>[</code>）。</p>
<p>在字符串中使用16进制转义序列如下所示：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> str = <span class="string">'\x4A\x61vaScript'</span>;  </div><div class="line"><span class="built_in">console</span>.log(str);                    <span class="comment">// =&gt; 'JavaScript'  </span></div><div class="line"><span class="keyword">var</span> reg = <span class="regexp">/\x4A\x61va.*/</span>;  </div><div class="line"><span class="built_in">console</span>.log(reg.test(<span class="string">'JavaScript'</span>)); <span class="comment">// =&gt; true</span></div></pre></td></tr></table></figure></p>
<p>16进制转义序列只能编码从U+00到U+FF的有限数量的代码点，因为它只能有2位数字。但16进制转义序列的好处是它很短。</p>
<p>Unicode转义序列</p>
<p>如果你想转义整个BMP中的代码点，那就用Unicode转义序列。转义形式是<code>\u&lt;hex&gt;</code>,<code>\u</code>为前缀，后面跟一个4位的16进制数。</p>
<p>比如 <code>\u0051</code> （字符 <code>Q</code>）和<code>\u222B</code> （积分符号 <code>∫</code>）.</p>
<p>像下面这样使用Unicode转义序列：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> str = <span class="string">'I\u0020learn \u0055nicode'</span>;  </div><div class="line"><span class="built_in">console</span>.log(str);                 <span class="comment">// =&gt; 'I learn Unicode'  </span></div><div class="line"><span class="keyword">var</span> reg = <span class="regexp">/\u0055ni.*/</span>;  </div><div class="line"><span class="built_in">console</span>.log(reg.test(<span class="string">'Unicode'</span>)); <span class="comment">// =&gt; true</span></div></pre></td></tr></table></figure></p>
<p>Unicode转义序列可以编码从<code>U+0000</code>到<code>U+FFFF</code>的有限数量的代码点（BMP中全部代码点），因为它可以有4位数字。大多数时候这已经足够用来表示常用字符了。</p>
<p>想要在JavaScript文本中表示星光字符，可以用两个连续的Unicode转义序列（高位代理与低位代理），生成代理对：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> str = <span class="string">'My face \uD83D\uDE00'</span>;  </div><div class="line"><span class="built_in">console</span>.log(str); <span class="comment">// =&gt; 'My face '</span></div></pre></td></tr></table></figure></p>
<p>代码点转义序列</p>
<p>ECMAScript 2015提供了能够表示整个Unicode空间：从<code>U+0000</code>到<code>U+10FFFF</code>，也就是BMP与星光平面的转义序列。</p>
<p>这种新格式被称为代码点转义序列：<code>\u{&lt;hex&gt;}</code>，<code>&lt;hex&gt;</code>是一个长度为1至6位的16进制数。 比如<code>\u{7A}</code>（字符<code>z</code>）和<code>\u{1F639}</code>（<code>Funny cat</code>符号）。</p>
<p>来看看它应该如何应用：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> str = <span class="string">'Funny cat \u&#123;1F639&#125;'</span>;  </div><div class="line"><span class="built_in">console</span>.log(str);                      <span class="comment">// =&gt; 'Funny cat '  </span></div><div class="line"><span class="keyword">var</span> reg = <span class="regexp">/\u&#123;1F639&#125;/u</span>;  </div><div class="line"><span class="built_in">console</span>.log(reg.test(<span class="string">'Funny cat '</span>)); <span class="comment">// =&gt; true</span></div></pre></td></tr></table></figure></p>
<p>注意正则表达式<code>/\u{1F639}/u</code>有一个特殊flag<code>u</code>,它支持额外的Unicode特性（详情见3.5正则匹配）。</p>
<p>我喜欢代码点转义不需要使用代理对来表示星光符号这一点。让我们来转义代码点<code>U+1F607 SMILING FACE WITH HALO</code>吧：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> niceEmoticon = <span class="string">'\u&#123;1F607&#125;'</span>;  </div><div class="line"><span class="built_in">console</span>.log(niceEmoticon);   <span class="comment">// =&gt; ''  </span></div><div class="line"><span class="keyword">var</span> spNiceEmoticon = <span class="string">'\uD83D\uDE07'</span>  </div><div class="line"><span class="built_in">console</span>.log(spNiceEmoticon); <span class="comment">// =&gt; ''  </span></div><div class="line"><span class="built_in">console</span>.log(niceEmoticon === spNiceEmoticon); <span class="comment">// =&gt; true</span></div></pre></td></tr></table></figure></p>
<p>被赋给变量niceEmoticon的字符串字面量包含一个代码点转义序列<code>\u{1F607}</code>，它表示一个星光代码点<code>U+1F607</code>。</p>
<p>然而在这种表象之下代码点转义序列依旧生成了一个代理对（2个码元）。我们可以看到变量spNiceEmoticon被赋值为使用代理对创建的Unicode转义序列<code>\uD83D\uDE07</code>，而它与变量niceEmoticon是相等的。<br><img src="/images/20170830/4.jpg" alt=""></p>
<p>如果正则表达式是用构造函数RegExp创建的，那么在字符串字面量中必须将每一个 <code>\</code>替换为<code>\\</code>来表示Unicode转义序列。</p>
<p>以下正则表达式对象是相等的：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> reg1 = <span class="regexp">/\x4A \u0020 \u&#123;1F639&#125;/</span>;  </div><div class="line"><span class="keyword">var</span> reg2 = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'\\x4A \\u0020 \\u&#123;1F639&#125;'</span>);  </div><div class="line"><span class="built_in">console</span>.log(reg1.source === reg2.source); <span class="comment">// =&gt; true</span></div></pre></td></tr></table></figure></p>
<h5 id="3-2-字符串比较"><a href="#3-2-字符串比较" class="headerlink" title="3.2 字符串比较"></a>3.2 字符串比较</h5><p>JavaScript中的字符串是码元的序列。因此字符串的比较可以看作是码元的计算与匹配。</p>
<p>这种方法快速而有效，对于“简单”的字符串不失为一种好方法。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> firstStr = <span class="string">'hello'</span>;  </div><div class="line"><span class="keyword">var</span> secondStr = <span class="string">'\u0068ell\u006F'</span>;  </div><div class="line"><span class="built_in">console</span>.log(firstStr === secondStr); <span class="comment">// =&gt; true</span></div></pre></td></tr></table></figure></p>
<p>字符串<code>firstStr</code>与<code>secondStr</code>包含相同的码元序列，故它们相等。</p>
<p>假设你想比较两个渲染结果相同，但包含不同码元序列的字符串。</p>
<p>那么你可能会得到意外的结果，因为看上去相同的字符串经过比较却不相等：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> str1 = <span class="string">'ça va bien'</span>;  </div><div class="line"><span class="keyword">var</span> str2 = <span class="string">'c\u0327a va bien'</span>;  </div><div class="line"><span class="built_in">console</span>.log(str1);          <span class="comment">// =&gt; 'ça va bien'  </span></div><div class="line"><span class="built_in">console</span>.log(str2);          <span class="comment">// =&gt; 'ça va bien'  </span></div><div class="line"><span class="built_in">console</span>.log(str1 === str2); <span class="comment">// =&gt; false</span></div></pre></td></tr></table></figure></p>
<p>str1和str2渲染结果看起来相同，但包含不同的码元。</p>
<p>因为字素<code>ç</code>可以通过两种方法生成：</p>
<ul>
<li>使用<code>U+00E7 LATIN SMALL LETTER C WITH CEDILLA</code></li>
<li>或者用组合字符序列：<code>U+0063 LATIN SMALL LETTER C</code> 加上组合用字符<code>U+0327COMBINING CEDILLA</code>.</li>
</ul>
<p>那么该如何处理这种情况，正确地比较字符串？答案是字符串标准化。</p>
<p>标准化</p>
<blockquote>
<p>标准化是指将字符串转换为统一的表示形式，以保证具有标准等价性（或兼容等价性）的字符串只有一种表示形式。</p>
</blockquote>
<p>换句话说，当字符串包含组合用字符序列或其他混合结构等复杂的结构时，我们可以将它统一成标准的形式。标准化的字符串在进行比较或文本查找等操作时就很轻松了。</p>
<p><code>Unicode Standard Annex #15</code>对标准化方法有详细地描述。</p>
<p>在JavaScript中对字符串进行标准化需要调用ES2015提供的<code>myString.normalize([normForm])</code>方法。<code>normForm</code>是一个可选参数（默认为<code>NFC</code>），取值为以下标准化模式之一：</p>
<ul>
<li>‘NFC’ as Normalization Form Canonical Composition（标准化形式-标准性合成）</li>
<li>‘NFD’ as Normalization Form Canonical Decomposition（标准化形式-标准性分解）</li>
<li>‘NFKC’ as Normalization Form Compatibility Composition（标准化形式-兼容性合成）</li>
<li>‘NFKD’ as Normalization Form Compatibility Decomposition（标准化形式-兼容性分解）</li>
</ul>
<p>让我们利用字符串标准化来改进上面的例子吧，这次可以正确地比较字符串了：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> str1 = <span class="string">'ça va bien'</span>;  </div><div class="line"><span class="keyword">var</span> str2 = <span class="string">'c\u0327a va bien'</span>;  </div><div class="line"><span class="built_in">console</span>.log(str1 === str2.normalize()); <span class="comment">// =&gt; true  </span></div><div class="line"><span class="built_in">console</span>.log(str1 === str2);</div></pre></td></tr></table></figure></p>
<p><code>ç</code>与<code>c\u0327</code>具有标准等价性。</p>
<p>调用<code>str2.normalize()</code>，会返回一个<code>str2</code> 的标准形式副本（<code>c\u0327</code>替换为<code>ç</code>）。因此比较语句<code>str1 === str2.normalize()</code>会如预期一般返回<code>true</code>.</p>
<p><code>str1</code>不受标准化影响，因为它已经是标准形式了。</p>
<p>但为了使操作符两端都取得标准化字符串，将待比较的2个字符串都标准化也是合理的。</p>
<h5 id="3-3-字符串长度"><a href="#3-3-字符串长度" class="headerlink" title="3.3 字符串长度"></a>3.3 字符串长度</h5><p>想要知道一个字符串的长度通常我们会访问<code>myString.length</code>这个属性。该属性表明了字符串中包含的码元个数。</p>
<p>对于只包含BMP代码点的字符串来说获取字符串长度通常都能符合预期：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> color = <span class="string">'Green'</span>;  </div><div class="line"><span class="built_in">console</span>.log(color.length); <span class="comment">// =&gt; 5</span></div></pre></td></tr></table></figure></p>
<p><code>color</code>中的每个码元都对应着一个字素。预期的字符串长度为<code>5</code>.</p>
<p>长度与代理对</p>
<p>当字符串中包含用来表示星光代码点的代理对时，事情就变得不对劲了。因为每个代理对包含2个码元（一个高位代理和一个低位代理），<code>length</code>属性值会比预期值要大。</p>
<p>比如这个例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> str = <span class="string">'cat\u&#123;1F639&#125;'</span>;  </div><div class="line"><span class="built_in">console</span>.log(str);        <span class="comment">// =&gt; 'cat'  </span></div><div class="line"><span class="built_in">console</span>.log(str.length); <span class="comment">// =&gt; 5</span></div></pre></td></tr></table></figure></p>
<p>字符串<code>str</code>的渲染结果是<code>4</code>个字符<code>cat</code>。</p>
<p>然而<code>smile.length</code>等于<code>5</code>，因为<code>U+1F639</code>是一个星光代码点，它被编码成了2个码元（一个代理对）。</p>
<p>不幸的是目前还没有一种高性能的原生方法能解决这个问题。</p>
<p>但至少ECMAScript 2015引入了一种能够识别星光字符的算法。星光字符即使被编译为2个码元，也会被计算为一个字符。</p>
<p>这个能够识别Unicode的利器就是字符迭代器<code>String.prototype[@@iterator]()</code>。你可以给字符串加上扩展操作符<code>[...str]</code>或<code>Array.from(str)</code>函数（两者都会调用字符串迭代器）。然后再计算返回数组中的字符个数。</p>
<p>需要注意的是这个解决方案如果大量使用可能会造成轻微的性能损失。</p>
<p>让我们用这个扩展操作符来改进上面的例子吧：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> str = <span class="string">'cat\u&#123;1F639&#125;'</span>;  </div><div class="line"><span class="built_in">console</span>.log(str);             <span class="comment">// =&gt; 'cat'  </span></div><div class="line"><span class="built_in">console</span>.log([...str]);        <span class="comment">// =&gt; ['c', 'a', 't', '']  </span></div><div class="line"><span class="built_in">console</span>.log([...str].length); <span class="comment">// =&gt; 4</span></div></pre></td></tr></table></figure></p>
<p><code>[...str]</code>创建了一个包含4个字符的数组。编码<code>U+1F639 CAT FACE WITH TEARS OF JOY</code> 的代理对原封不动地保留了下来，因为字符串迭代器能够识别Unicode。</p>
<p>长度与组合用字符</p>
<p>那么组合字符序列呢？由于每个组合用字符都是一个码元，因此你会遇到同样的困难。</p>
<p>这个问题对于标准化的字符串可以不用担心。如果运气好，组合字符序列会被标准化为单个字符。我们来试试看：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> drink = <span class="string">'cafe\u0301'</span>;  </div><div class="line"><span class="built_in">console</span>.log(drink);                    <span class="comment">// =&gt; 'café'  </span></div><div class="line"><span class="built_in">console</span>.log(drink.length);             <span class="comment">// =&gt; 5  </span></div><div class="line"><span class="built_in">console</span>.log(drink.normalize())         <span class="comment">// =&gt; 'café'  </span></div><div class="line"><span class="built_in">console</span>.log(drink.normalize().length); <span class="comment">// =&gt; 4</span></div></pre></td></tr></table></figure></p>
<p>字符串<code>drink</code>包含5个码元（因此<code>drink.length</code>等于5），尽管它只显示4个字符。</p>
<p>在标准化<code>drink</code>时，我们幸运地发现组合字符序列<code>e\u0301</code>有标准形式<code>é</code>。因此<code>drink.normalize().length</code>返回了预期的<code>4</code>。</p>
<p>不幸的是标准化并不能解决所有问题。那些比较长的组合字符序列并不都有对应的单个字符标准形式。比如这个例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> drink = <span class="string">'cafe\u0327\u0301'</span>;  </div><div class="line"><span class="built_in">console</span>.log(drink);                    <span class="comment">// =&gt; 'cafȩ́'  </span></div><div class="line"><span class="built_in">console</span>.log(drink.length);             <span class="comment">// =&gt; 6  </span></div><div class="line"><span class="built_in">console</span>.log(drink.normalize());        <span class="comment">// =&gt; 'cafȩ́'  </span></div><div class="line"><span class="built_in">console</span>.log(drink.normalize().length); <span class="comment">// =&gt; 5</span></div></pre></td></tr></table></figure></p>
<p><code>drink</code>包含6个码元所以<code>drink.length</code>值为<code>6</code>。然而drink只包含4个字符。</p>
<p>标准化函数<code>drink.normalize()</code>将组合序列<code>e\u0327\u0301</code>转换为含有2个字符的标准形式<code>ȩ\u0301</code>（只去掉了一个组合用字符）。于是我们很难过地发现<code>drink.normalize().length</code>的值为<code>5</code>，仍然不能正确地计算字符的个数。</p>
<h5 id="3-4-字符定位"><a href="#3-4-字符定位" class="headerlink" title="3.4 字符定位"></a>3.4 字符定位</h5><p>由于字符串是码元的序列，通过字符串索引来访问字符同样会有困难。</p>
<p>如果字符串只包含BMP字符（除了从<code>U+D800</code>到<code>U+DBFF</code>的高位代理和从<code>U+DC00</code>到<code>U+DFFF</code>的低位代理），字符定位可以得到正确的结果。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> str = <span class="string">'hello'</span>;  </div><div class="line"><span class="built_in">console</span>.log(str[<span class="number">0</span>]); <span class="comment">// =&gt; 'h'  </span></div><div class="line"><span class="built_in">console</span>.log(str[<span class="number">4</span>]); <span class="comment">// =&gt; 'o'</span></div></pre></td></tr></table></figure></p>
<p>上例中每个字符被编码为一个码元，因此通过索引访问字符可以得到正确的结果。</p>
<p>字符定位与代理对</p>
<p>当字符串中包含星光字符时情况就不一样了。</p>
<p>星光字符被编码为2个码元（一个代理对）。因此通过索引来访问字符可能会返回一个单独的高位代理或低位代理，而单独的高位/低位代理是无效字符。</p>
<p>下面这个例子演示了访问星光字符的情形：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> omega = <span class="string">'\u&#123;1D6C0&#125; is omega'</span>;  </div><div class="line"><span class="built_in">console</span>.log(omega);        <span class="comment">// =&gt; ' is omega'  </span></div><div class="line"><span class="built_in">console</span>.log(omega[<span class="number">0</span>]);     <span class="comment">// =&gt; '' (unprintable symbol)  </span></div><div class="line"><span class="built_in">console</span>.log(omega[<span class="number">1</span>]);     <span class="comment">// =&gt; '' (unprintable symbol)</span></div></pre></td></tr></table></figure></p>
<p>由于<code>U+1D6C0 MATHEMATICAL BOLD CAPITAL OMEGA</code>是一个星光字符，它的编码使用了一个代理对，即2个码元。</p>
<p><code>omega[0]</code>访问的是高位代理码元而<code>omega[1]</code>访问的是低位代理码元，代理对被分成了两半。</p>
<p>想要正确地访问字符串中星光字符，有2种方法：</p>
<ul>
<li>使用能够识别Unicode的字符串迭代器生成一个字符数组<code>[...str][index]</code></li>
<li>用<code>number = myString.codePointAt(index)</code>获取代码点，然后用<code>String.fromCodePoint(number)</code>将代码点转换为字符（推荐方法）</li>
</ul>
<p>让我们来尝试一下这两种方法：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> omega = <span class="string">'\u&#123;1D6C0&#125; is omega'</span>;  </div><div class="line"><span class="built_in">console</span>.log(omega);                        <span class="comment">// =&gt; ' is omega'  </span></div><div class="line"><span class="comment">// Option 1</span></div><div class="line"><span class="built_in">console</span>.log([...omega][<span class="number">0</span>]);                <span class="comment">// =&gt; ''  </span></div><div class="line"><span class="comment">// Option 2</span></div><div class="line"><span class="keyword">var</span> number = omega.codePointAt(<span class="number">0</span>);  </div><div class="line"><span class="built_in">console</span>.log(number.toString(<span class="number">16</span>));          <span class="comment">// =&gt; '1d6c0'  </span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>.fromCodePoint(number)); <span class="comment">// =&gt; ''</span></div></pre></td></tr></table></figure></p>
<p><code>[...smile]</code>返回一个包含字符串<code>omega</code>中字符的数组。代理对被正确识别，因此访问第一个字符返回了符合预期的结果：<code>[...smile][0]</code>返回<code>&#39;&#39;</code>.</p>
<p>函数<code>omega.codePointAt(0)</code>能够识别Unicode，因此它返回了字符串<code>omega</code>第一个字符的星光代码点数字<code>0x1D6C0</code>。函数<code>String.fromCodePoint(number)</code>则返回了这个代码点对应的字符：<code>&#39;&#39;</code>。</p>
<p>字符定位与组合用字符</p>
<p>字符定位在遇到组合用字符时会出现和上面一样的问题。</p>
<p>通过索引访问字符实际上是访问码元。然而组合字符序列应该被整体访问，而不是被分成单个的码元。</p>
<p>下面这个例子演示了这个问题：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> drink = <span class="string">'cafe\u0301'</span>;  </div><div class="line"><span class="built_in">console</span>.log(drink);        <span class="comment">// =&gt; 'café'  </span></div><div class="line"><span class="built_in">console</span>.log(drink.length); <span class="comment">// =&gt; 5  </span></div><div class="line"><span class="built_in">console</span>.log(drink[<span class="number">3</span>]);     <span class="comment">// =&gt; 'e'  </span></div><div class="line"><span class="built_in">console</span>.log(drink[<span class="number">4</span>]);     <span class="comment">// =&gt; ◌́</span></div></pre></td></tr></table></figure></p>
<p><code>drink[3]</code>只访问到了基础字符<code>e</code>,没有包括组合用字符<code>U+0301 COMBINING ACUTE ACCENT</code>（渲染为<code>◌́</code>）。</p>
<p><code>drink[4]</code>访问的是独立的组合用字符 `◌`` 。</p>
<p>这种情况需要使用字符串标准化。组合字符序列<code>U+0065 LATIN SMALL LETTER E +U+0301 COMBINING ACUTE ACCENT</code>有对应的标准形式<code>U+00E9 LATIN SMALL LETTER E WITH ACUTE</code>é`</p>
<p>我们来改进一下前面的例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> drink = <span class="string">'cafe\u0301'</span>;  </div><div class="line"><span class="built_in">console</span>.log(drink.normalize());        <span class="comment">// =&gt; 'café'  </span></div><div class="line"><span class="built_in">console</span>.log(drink.normalize().length); <span class="comment">// =&gt; 4  </span></div><div class="line"><span class="built_in">console</span>.log(drink.normalize()[<span class="number">3</span>]);     <span class="comment">// =&gt; 'é'</span></div></pre></td></tr></table></figure></p>
<p>需要注意的是并非所有组合字符序列都有对应的单个标准字符。因此标准化并不能解决所有问题。</p>
<p>好在对于欧洲/北美语言来说它可以解决大部分问题。</p>
<h5 id="3-5-正则匹配"><a href="#3-5-正则匹配" class="headerlink" title="3.5 正则匹配"></a>3.5 正则匹配</h5><p>正则表达式与字符串一样，是基于码元工作的。因此与上文描述的情形相似，使用正则表达式在处理代理对和组合字符序列时也会遇到困难。</p>
<p>BMP字符的匹配是符合预期的，因为一个码元对应一个字符：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> greetings = <span class="string">'Hi!'</span>;  </div><div class="line"><span class="keyword">var</span> regex = <span class="regexp">/.&#123;3&#125;/</span>;  </div><div class="line"><span class="built_in">console</span>.log(regex.test(greetings)); <span class="comment">// =&gt; true</span></div></pre></td></tr></table></figure></p>
<p><code>greetings</code>有3个字符，编码为3个码元。正则表达式<code>/.{3}/</code>期望的是3个码元，因此与<code>greetings</code>匹配成功。</p>
<p>在匹配星光字符（被编码为2个码元的代理对）时，你可能会遇到困难：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> smile = <span class="string">''</span>;  </div><div class="line"><span class="keyword">var</span> regex = <span class="regexp">/^.$/</span>;  </div><div class="line"><span class="built_in">console</span>.log(regex.test(smile)); <span class="comment">// =&gt; false</span></div></pre></td></tr></table></figure></p>
<p><code>smile</code>包含星光字符<code>U+1F600 GRINNING FACE</code>。<code>U+1F600</code>被编码为一个代理对<code>0xD83D 0xDE00</code>。</p>
<p>然而正则表达式<code>/^.$/</code>期望的是<code>1</code>个码元，于是正则匹配<code>regexp.test(smile)</code>失败了。</p>
<p>在定义字符区间的时候情况会更糟。JavaScript直接报错了：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> regex = <span class="regexp">/[-]/</span>;  </div><div class="line"><span class="comment">// =&gt; SyntaxError: Invalid regular expression: /[-]/:</span></div><div class="line"><span class="comment">// Range out of order in character class</span></div></pre></td></tr></table></figure></p>
<p>星光代码点会被编码为代理对，因此JavaScript会用码元<code>/[\uD83D\uDE00-\uD83D\uDE0E]/</code>来表示这个正则表达式。而在<code>pattern</code>中每个码元被视为一个单独的元素，所以正则表达式会忽略代理对这个概念。</p>
<p>又由于<code>\uDE00比\uD83D</code>大，<code>\uDE00-\uD83D</code>这个字符区间是无效的，所以就报错了。</p>
<p>正则表达式 <code>u</code> 标志</p>
<p>好在ECMAScript 2015引入了u标志，使得正则表达式能够识别Unicode。这个标志让我们能够正确处理星光字符。</p>
<p>在正则表达式中可以使用Unicode转义序列<code>/u{1F600}/u</code>。这样比写高位代理和低位代理<code>/\uD83D\uDE00/</code>要短。</p>
<p>让我们来尝试应用一下<code>u</code>标志，看看<code>.</code>操作符（包括量词<code>?、+、*和{3}、{3,}, {2,3}</code>）能否匹配星光字符：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> smile = <span class="string">''</span>;  </div><div class="line"><span class="keyword">var</span> regex = <span class="regexp">/^.$/u</span>;  </div><div class="line"><span class="built_in">console</span>.log(regex.test(smile)); <span class="comment">// =&gt; true</span></div></pre></td></tr></table></figure></p>
<p>正则表达式<code>/^.$/u</code>由于加上了<code>u</code>标志而能够识别Unicode，因此正确地匹配了星光字符。</p>
<p>u标志还能使星光字符区间被正确处理：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> smile = <span class="string">''</span>;  </div><div class="line"><span class="keyword">var</span> regex = <span class="regexp">/[-]/u</span>;  </div><div class="line"><span class="keyword">var</span> regexEscape = <span class="regexp">/[\u&#123;1F600&#125;-\u&#123;1F60E&#125;]/u</span>;  </div><div class="line"><span class="keyword">var</span> regexSpEscape = <span class="regexp">/[\uD83D\uDE00-\uD83D\uDE0E]/u</span>;  </div><div class="line"><span class="built_in">console</span>.log(regex.test(smile));         <span class="comment">// =&gt; true  </span></div><div class="line"><span class="built_in">console</span>.log(regexEscape.test(smile));   <span class="comment">// =&gt; true  </span></div><div class="line"><span class="built_in">console</span>.log(regexSpEscape.test(smile)); <span class="comment">// =&gt; true</span></div></pre></td></tr></table></figure></p>
<p>现在<code>[-]</code>被视为一个星光字符的区间了。<code>/[-]/u</code>成功匹配了<code>&#39;&#39;</code>。</p>
<p>正则表达式与组合用字符</p>
<p>不幸的是不论有没有u标志，正则表达式都会把组合用标记视为独立的码元来处理。</p>
<p>要匹配组合字符序列，只能分别匹配基础字符与组合用字符。</p>
<p>看下面的例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> drink = <span class="string">'cafe\u0301'</span>;  </div><div class="line"><span class="keyword">var</span> regex1 = <span class="regexp">/^.&#123;4&#125;$/</span>;  </div><div class="line"><span class="keyword">var</span> regex2 = <span class="regexp">/^.&#123;5&#125;$/</span>;  </div><div class="line"><span class="built_in">console</span>.log(drink);              <span class="comment">// =&gt; 'café'  </span></div><div class="line"><span class="built_in">console</span>.log(regex1.test(drink)); <span class="comment">// =&gt; false  </span></div><div class="line"><span class="built_in">console</span>.log(regex2.test(drink)); <span class="comment">// =&gt; true</span></div></pre></td></tr></table></figure></p>
<p>字符串渲染为4个字符<code>café</code>。</p>
<p>然而成功匹配<code>cafe\u0301</code>的正则表达式是匹配5个元素的<code>/^.{5}$/</code>。</p>
<h4 id="4-结语"><a href="#4-结语" class="headerlink" title="4. 结语"></a>4. 结语</h4><p>也许在JavaScript中有关Unicode的最重要的概念就是将字符串视为码元序列，事实也确实如此。</p>
<p>如果开发者认为字符串是由字素（或字符）组成，忽略码元序列这个概念，就会感到困惑。</p>
<p>在处理包含代理对或组合字符序列的字符串时这种想法会造成误解。</p>
<ul>
<li>获取字符串长度</li>
<li>字符定位</li>
<li>正则匹配</li>
</ul>
<p>注意JavaScript中大多数字符串方法都不能识别Unicode：比如<code>myString.indexOf()</code>、<code>myString.slice()</code>等。</p>
<p>ECMAScript 2015在字符串和正则表达式中增加了一些很棒的特性，例如代码点转义序列<code>\u{1F600}</code>。</p>
<p>新的正则表达式标志<code>u</code>使字符串匹配能够识别Unicode，这样一来匹配星光字符就简单多了。</p>
<p>字符串迭代器<code>String.prototype[@@iterator]()</code>能够识别Unicode。使用扩展操作符<code>[...str]或Array.from(str)</code>可以创建一个字符数组，通过这个数组的下标来计算字符串长度或访问字符就不会把代理对拆开了。但要注意这种方法会影响性能。</p>
<p>如果你需要更好的办法来处理Unicode字符，你可以使用punycode库或者生成特殊的正则表达式。</p>
<p>但愿此文能帮助你掌握Unicode！</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        
  <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
    <div>坚持原创技术分享，您的支持将鼓励我继续创作！</div>
    <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
      <span>赏</span>
    </button>
    <div id="QR" style="display: none;">
      
        <div id="wechat" style="display: inline-block">
          <img id="wechat_qr" src="/images/wechat-reward.png" alt="来利强 WeChat Pay"/>
          <p>微信打赏</p>
        </div>
      
      
    </div>
  </div>


      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/JavaScript/" rel="tag">#JavaScript</a>
          
            <a href="/tags/Unicode/" rel="tag">#Unicode</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/08/25/ECMAScript6学习笔记（不定期更新）/" rel="next" title="ECMAScript6学习笔记（不定期更新）">
                <i class="fa fa-chevron-left"></i> ECMAScript6学习笔记（不定期更新）
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2017/08/30/每个JavaScript开发者都该懂的Unicode/"
           data-title="每个JavaScript开发者都该懂的Unicode" data-url="http://liqianglai.github.com/2017/08/30/每个JavaScript开发者都该懂的Unicode/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="//schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="来利强" />
          <p class="site-author-name" itemprop="name">来利强</p>
          <p class="site-description motion-element" itemprop="description">公旦叫我了</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">17</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">10</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">23</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              More
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://blog.csdn.net/liqianglai" title="CSDN" target="_blank">CSDN</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="https://git.oschina.net/lailiqiang" title="码云" target="_blank">码云</a>
                </li>
              
            </ul>
          </div>
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-Unicode背后的思想"><span class="nav-text">1. Unicode背后的思想</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-Unicode基本概念"><span class="nav-text">2. Unicode基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2-1-字符与代码点"><span class="nav-text">2.1 字符与代码点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-2-Unicode平面"><span class="nav-text">2.2 Unicode平面</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#基本多文种平面"><span class="nav-text">基本多文种平面</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#星光平面"><span class="nav-text">星光平面</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-3-码元"><span class="nav-text">2.3 码元</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-4-代理对"><span class="nav-text">2.4 代理对</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-5-组合用字符"><span class="nav-text">2.5 组合用字符</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-JavaScript中的Unicode"><span class="nav-text">3. JavaScript中的Unicode</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-1-转义序列"><span class="nav-text">3.1 转义序列</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-2-字符串比较"><span class="nav-text">3.2 字符串比较</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-3-字符串长度"><span class="nav-text">3.3 字符串长度</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-4-字符定位"><span class="nav-text">3.4 字符定位</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-5-正则匹配"><span class="nav-text">3.5 正则匹配</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-结语"><span class="nav-text">4. 结语</span></a></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2016 - 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">来利强</span>
</div>

<div class="powered-by">
  Powered by <a class="theme-link" href="https://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.0.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.2"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.2"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"lailiqiang"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    <script src="/vendors/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  






  
  

  

  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("1u9x2uzGgWmdeRjJ4Qhwlcip-gzGzoHsz", "DjerQVUz4ARxsgRLD62u9xuY");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

</body>
</html>
